% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/heatmap.R, R/pls_analysis.R, R/plsda_analysis.R
\name{Heatmap,mass_dataset-method}
\alias{Heatmap,mass_dataset-method}
\alias{pls,mass_dataset-method}
\alias{plsda,mass_dataset-method}
\title{Heatmap}
\usage{
\S4method{Heatmap}{mass_dataset}(
  matrix,
  col,
  name = "value",
  na_col = "grey",
  color_space = "LAB",
  rect_gp = grid::gpar(col = NA),
  border = NA,
  border_gp = grid::gpar(col = "black"),
  cell_fun = NULL,
  layer_fun = NULL,
  jitter = FALSE,
  row_title = character(0),
  row_title_side = c("left", "right"),
  row_title_gp = grid::gpar(fontsize = 13.2),
  row_title_rot = switch(row_title_side[1], left = 90, right = 270),
  column_title = character(0),
  column_title_side = c("top", "bottom"),
  column_title_gp = grid::gpar(fontsize = 13.2),
  column_title_rot = 0,
  cluster_rows = TRUE,
  cluster_row_slices = TRUE,
  clustering_distance_rows = "euclidean",
  clustering_method_rows = "complete",
  row_dend_side = c("left", "right"),
  row_dend_width = unit(10, "mm"),
  show_row_dend = TRUE,
  row_dend_reorder = is.logical(cluster_rows) || is.function(cluster_rows),
  row_dend_gp = grid::gpar(),
  cluster_columns = TRUE,
  cluster_column_slices = TRUE,
  clustering_distance_columns = "euclidean",
  clustering_method_columns = "complete",
  column_dend_side = c("top", "bottom"),
  column_dend_height = unit(10, "mm"),
  show_column_dend = TRUE,
  column_dend_gp = grid::gpar(),
  column_dend_reorder = is.logical(cluster_columns) || is.function(cluster_columns),
  row_order = NULL,
  column_order = NULL,
  row_labels = rownames(matrix),
  row_names_side = c("right", "left"),
  show_row_names = TRUE,
  row_names_max_width = unit(6, "cm"),
  row_names_gp = grid::gpar(fontsize = 12),
  row_names_rot = 0,
  row_names_centered = FALSE,
  column_labels = colnames(matrix),
  column_names_side = c("bottom", "top"),
  show_column_names = TRUE,
  column_names_max_height = unit(6, "cm"),
  column_names_gp = grid::gpar(fontsize = 12),
  column_names_rot = 90,
  column_names_centered = FALSE,
  top_annotation = NULL,
  bottom_annotation = NULL,
  left_annotation = NULL,
  right_annotation = NULL,
  km = 1,
  split = NULL,
  row_km = km,
  row_km_repeats = 1,
  row_split = split,
  column_km = 1,
  column_km_repeats = 1,
  column_split = NULL,
  gap = unit(1, "mm"),
  row_gap = unit(1, "mm"),
  column_gap = unit(1, "mm"),
  show_parent_dend_line = ComplexHeatmap::ht_opt$show_parent_dend_line,
  heatmap_width = unit(1, "npc"),
  width = NULL,
  heatmap_height = unit(1, "npc"),
  height = NULL,
  show_heatmap_legend = TRUE,
  heatmap_legend_param = list(title = name),
  use_raster = NULL,
  raster_device = c("png", "jpeg", "tiff", "CairoPNG", "CairoJPEG", "CairoTIFF",
    "agg_png"),
  raster_quality = 1,
  raster_device_param = list(),
  raster_resize_mat = FALSE,
  raster_by_magick = requireNamespace("magick", quietly = TRUE),
  raster_magick_filter = NULL,
  post_fun = NULL
)

\S4method{pls}{mass_dataset}(
  X,
  Y = NULL,
  ncomp = 2,
  scale = FALSE,
  mode = c("regression", "canonical", "invariant", "classic"),
  tol = 1e-06,
  max.iter = 100,
  near.zero.var = FALSE,
  logratio = "none",
  multilevel = NULL,
  all.outputs = TRUE
)

\S4method{plsda}{mass_dataset}(
  X,
  Y = NULL,
  ncomp = 2,
  scale = FALSE,
  tol = 1e-06,
  max.iter = 100,
  near.zero.var = FALSE,
  logratio = "none",
  multilevel = NULL,
  all.outputs = TRUE
)
}
\arguments{
\item{X}{mass_dataset}

\item{Y}{a factor or a class vector for the discrete outcome.}

\item{ncomp}{ncomp}

\item{scale}{scale}

\item{mode}{mode}

\item{tol}{tol}

\item{max.iter}{max.iter}

\item{near.zero.var}{near.zero.var}

\item{logratio}{logratio}

\item{multilevel}{multilevel}

\item{all.outputs}{all.outputs}
}
\value{
A heatmap

library(massdataset)
library(tidyverse)
data("liver_aging_pos")

qc_id <-
  liver_aging_pos %>%
  activate_mass_dataset(what = "sample_info") %>%
  dplyr::filter(group == "QC") %>%
  dplyr::pull(sample_id)
object <-
  mutate_rsd(liver_aging_pos, according_to_samples = qc_id)

###only remain the features with rt > 100, mz > 150 and rsd < 30
object <-
  object %>%
  activate_mass_dataset(what = "variable_info") %>%
  dplyr::filter(rt > 100) %>%
  dplyr::filter(mz > 150) %>%
  dplyr::filter(rsd < 30)


matrix <-
  object %>%
  `+`(1) %>%
  log(10) %>%
  scale_data()

Heatmap(matrix = matrix, name = "z-score")

A pls class

A plsda class
}
\description{
#' @method pls mass_dataset
#' @docType methods
#' @importFrom mixOmics pls plotIndiv plotVar
#' @export
}
\details{
# data("liver_aging_pos")
# 
# X <- liver_aging_pos
# X <-
#   X %>%
#   activate_mass_dataset(what = "sample_info") %>%
#   dplyr::filter(group != "QC")
# 
# Y <- X@sample_info$group
# Y = convert_dummy_variable(y = Y)
# 
# pls_object <-
#   mixOmics::pls(X, Y = Y, ncomp = 2)
# 
# plotIndiv(pls_object)
# plotVar(pls_object)

pls.mass_dataset <-
  function(X,
           Y = NULL,
           ncomp = 2,
           scale = FALSE,
           mode = c("regression", "canonical", "invariant", "classic"),
           tol = 1e-06,
           max.iter = 100,
           near.zero.var = FALSE,
           logratio = "none",
           multilevel = NULL,
           all.outputs = TRUE) {
    mode <- match.arg(mode)
    expression_data = X@expression_data
    
    linn.pls <- 
    mixOmics::pls(
      X = as.matrix(t(expression_data)),
      Y = Y,
      ncomp = ncomp,
      scale = FALSE,
      mode = mode, tol = tol,
      max.iter = max.iter, 
      near.zero.var = near.zero.var, 
      logratio = logratio,
      multilevel = multilevel, 
      all.outputs = all.outputs
    )
    return(linn.pls)
  }
}
